### **Lab: Authorization and Centralized Error Handling**

Our application is becoming more robust. We have authentication, which confirms *who* a user is. However, we're still missing a crucial security layer: **authorization**, which determines what a user is *allowed to do*. Currently, any logged-in user can edit or delete *any* post in the database, which is a major security flaw.

In this lab, we will implement proper authorization to enforce data ownership. At the same time, we'll clean up our code by creating a single, centralized error-handling middleware. This will make our controllers leaner and our API's error responses consistent and professional.

#### **Prerequisites**

*   Completion of the "User Login with JWT and Middleware" lab.
*   Your MySQL database server is running.
*   An API client like Postman or Insomnia.

#### **Learning Objectives**

By the end of this lab, you will be able to:

*   Implement authorization logic to enforce data ownership.
*   Differentiate between 401 Unauthorized and 403 Forbidden HTTP status codes.
*   Create a centralized error-handling middleware in Express.
*   Refactor services and controllers to rely on the centralized handler, making them cleaner.
*   Understand how to gracefully handle both expected and unexpected errors in an API.

---

### **Part 1: The Problem - Demonstrating the Authorization Flaw**

Before we fix the issue, let's prove it exists. For this, you will need two different registered users.

1.  **Register User A:** `POST /api/auth/register` with "userA@example.com".
2.  **Login as User A:** `POST /api/auth/login` and get their JWT.
3.  **Create a Post as User A:** Using User A's JWT, `POST /api/posts` to create a new post. Note the `id` of this post (e.g., `id: 1`).
4.  **Register User B:** `POST /api/auth/register` with "userB@example.com".
5.  **Login as User B:** `POST /api/auth/login` and get their JWT.
6.  **The Flaw:** Using **User B's JWT**, make a `DELETE` request to the post created by User A (e.g., `DELETE /api/posts/1`).

You will see a `200 OK` response. **User B has successfully deleted User A's post.** This is the problem we need to fix.

---

### **Part 2: Implementing Authorization Logic**

The rule is simple: a user can only update or delete a post if the post's `authorId` matches their own user `id`. The best place to enforce this business logic is in the **service layer**.

**1. Update the Post Service (`post.service.js`)**

We need to modify `updatePost` and `deletePost` to check for ownership before performing the action.

*   Open `src/services/post.service.js` and update it.

```javascript
// src/services/post.service.js
import pool from '../config/db.js';
import { ApiError } from '../utils/ApiError.js';

// ... (createPost, getPostById, getAllPosts remain the same)

export const updatePost = async (id, postData, userId) => { // Add userId as an argument
    const { title, content } = postData;

    // First, get the post to check for ownership
    const post = await getPostById(id); // This will throw a 404 if not found

    // AUTHORIZATION CHECK
    if (post.authorId !== userId) {
        throw new ApiError(403, "Forbidden: You do not have permission to edit this post.");
    }

    // If the check passes, proceed with the update
    await pool.query(
        'UPDATE posts SET title = ?, content = ? WHERE id = ?',
        [title, content, id]
    );
    const updatedPost = await getPostById(id);
    return updatedPost;
};

export const deletePost = async (id, userId) => { // Add userId as an argument
    // First, get the post to check for ownership
    const post = await getPostById(id); // This will throw a 404 if not found

    // AUTHORIZATION CHECK
    if (post.authorId !== userId) {
        throw new ApiError(403, "Forbidden: You do not have permission to delete this post.");
    }
    
    // If the check passes, proceed with the deletion
    const [result] = await pool.query('DELETE FROM posts WHERE id = ?', [id]);
    return result.affectedRows;
};
```

> #### **Code Explanation**
> *   We now require a `userId` to be passed to both `updatePost` and `deletePost`.
> *   Before any action is taken, we fetch the post from the database.
> *   `if (post.authorId !== userId)`: This is the core authorization logic. We compare the ID of the post's author with the ID of the user making the request.
> *   `throw new ApiError(403, ...)`: If the IDs do not match, we throw a new `ApiError` with the status code **403 Forbidden**. This is the correct code to use.
>     *   **401 Unauthorized** means "You are not logged in."
>     *   **403 Forbidden** means "You are logged in, but you are not allowed to access this resource."

**2. Update the Post Controller and Routes**

Now we need to pass the authenticated user's ID from the controller to the service and protect the routes.

*   Open `src/controllers/post.controller.js`.

```javascript
// src/controllers/post.controller.js
// ... (imports and other functions)

export const updatePost = asyncHandler(async (req, res) => {
    const postId = parseInt(req.params.id, 10);
    const postData = req.body;
    const userId = req.user.id; // Get the user ID from the middleware

    const updatedPost = await postService.updatePost(postId, postData, userId);
    res.status(200).json(new ApiResponse(200, updatedPost, "Post updated successfully"));
});

export const deletePost = asyncHandler(async (req, res) => {
    const postId = parseInt(req.params.id, 10);
    const userId = req.user.id; // Get the user ID from the middleware

    await postService.deletePost(postId, userId);
    res.status(200).json(new ApiResponse(200, null, "Post deleted successfully"));
});
```

*   Open `src/routes/post.routes.js` to protect the update and delete routes.

```javascript
// src/routes/post.routes.js
// ... (imports)

// ... (GET and POST routes)
router.post('/', authMiddleware, validatePost, postController.createPost);

// PROTECT THESE ROUTES AS WELL
router.put('/:id', authMiddleware, validatePost, postController.updatePost);
router.delete('/:id', authMiddleware, postController.deletePost);

export default router;
```

---

### **Part 3: Creating the Centralized Error Handler**

Right now, our `asyncHandler` catches errors, but the default Express handler sends back HTML or a messy JSON response. We want all our errors to be sent in the same clean format as our `ApiResponse`.

*   Create a new file: `src/middlewares/errorHandler.middleware.js`.

```javascript
// src/middlewares/errorHandler.middleware.js
import { ApiError } from '../utils/ApiError.js';

export const errorHandler = (err, req, res, next) => {
    let statusCode = err.statusCode || 500;
    let message = err.message || "Internal Server Error";

    // If the error is an instance of our custom ApiError, we trust its values
    if (!(err instanceof ApiError)) {
        // For unexpected errors, log them for debugging
        console.error(err);

        // In a production environment, you wouldn't want to send
        // potentially sensitive error details to the client.
        if (process.env.NODE_ENV === 'production') {
            message = "Something went wrong!";
        }
    }

    const response = {
        success: false,
        message: message,
    };

    // Only include the stack trace in development mode
    if (process.env.NODE_ENV === 'development') {
        response.stack = err.stack;
    }

    res.status(statusCode).json(response);
};
```

> #### **Code Explanation**
> *   This is a special type of Express middleware with four arguments `(err, req, res, next)`, which Express specifically uses for handling errors.
> *   We check if the error `err` is one of our custom `ApiError`s. If it is, we can use the status code and message we defined.
> *   If it's an unexpected error (e.g., a database connection failure), we default to a `500 Internal Server Error` and log the real error for our own debugging.
> *   The `NODE_ENV` check is a crucial best practice for security. It ensures that internal implementation details (like the stack trace) are never sent to the client in a production environment.

**4. Integrate the Error Handler in `index.js`**

To use our new error handler, we must add it as the **very last piece of middleware** in our `index.js` file.

*   Open `index.js` and make the following changes.

```javascript
// index.js
// ... (all other imports)
import { errorHandler } from './src/middlewares/errorHandler.middleware.js'; // IMPORT

const app = express();
// ... (app.use(express.json()))

// ... (all your app.use('/api/...') routes)

// USE THE ERROR HANDLER
// This must be the LAST middleware in the chain
app.use(errorHandler);

app.listen(port, () => {
    // ...
});
```

---

### **Part 4: Testing the Complete Solution**

Let's re-run the test from Part 1 and see our new security and error handling in action.

1.  **Start your server:** `node index.js`.
2.  **Login as User B:** Use the credentials for "userB@example.com" to get a fresh JWT.
3.  **Attempt to Delete User A's Post:** Using **User B's JWT**, make a `DELETE` request to the post created by User A (e.g., `DELETE /api/posts/1`).
4.  **Check the Response:** This time, you should not get a `200 OK`. Instead, you will receive a `403 Forbidden` status code and a clean JSON error response from our new `errorHandler`:
    ```json
    {
        "success": false,
        "message": "Forbidden: You do not have permission to delete this post."
    }
    ```
5.  **Test the "Not Found" Case:** Try to delete a post that doesn't exist (e.g., `DELETE /api/posts/999`). You should get a `404 Not Found` with the message "Post not found".
6.  **Test the "Happy Path":** Login as **User A**. Use User A's JWT to delete the post they created. This should work, and you should receive a `200 OK` from your `ApiResponse`.

Congratulations! You have now implemented a vital security layer with Authorization, ensuring data integrity. You have also significantly improved your code's architecture and the professionalism of your API by creating a robust, centralized error handler.