### **Lab: Environment Variables and Basic Logging**

Welcome to the next lab in our series. We will learn how to manage application configuration safely and how to add logging to monitor the requests our server receives.

#### **Prerequisites**

*   Completion of the "Separation of Concerns" lab. You should have the project structured with `routes`, `controllers`, and `services`.

#### **Learning Objectives**

By the end of this lab, you will be able to:

*   Understand why hardcoding configuration is a bad practice.
*   Use environment variables to manage application settings.
*   Secure sensitive information using `.env` files.
*   Properly ignore files like `.env` and `node_modules` in version control.
*   Implement a request logger to monitor API traffic.

---

### **Part 1: The Problem with Hardcoded Configuration**

Take a look at our `index.js` file:

```javascript
// index.js
import express from 'express';
import postRoutes from './src/routes/post.routes.js';

const app = express();
const port = 3000; // <-- This is hardcoded!

// ... rest of the file
```

The port `3000` is hardcoded. What's wrong with this?

*   **Inflexibility:** What if you need to run the app on a different port in production? You would have to change the code, which is risky.
*   **Security:** What if this were a database password or an API key? Committing secrets directly into your code is a major security vulnerability. Anyone with access to your code repository would see them.

The solution is to use **environment variables**. These are variables that live outside your application's code and can be configured differently for your development machine, a testing server, or the production environment.

---

### **Part 2: Practical Work - Implementing `dotenv` and `.gitignore`**

We will use the popular `dotenv` package to load environment variables from a `.env` file into our application.

**1. Install `dotenv`**

In your terminal, at the root of your project, run:

```bash
npm install dotenv
```

**2. Create the `.env` File**

Create a new file in the **root** of your project named `.env`.

```
/express-separation-of-concerns-lab
|-- /src
|-- .env   <-- Create this file
|-- index.js
|-- package.json
|-- package-lock.json
```

Inside the `.env` file, add the following line. Note that there are no quotes.

```
PORT=3000
```

**3. Load and Use the Environment Variable**

Now, let's modify `index.js` to use this new variable. We need to import and configure `dotenv` at the very top of our application's entry file (`index.js`) so that the variables are available everywhere else.

Update your `index.js` to look like this:

```javascript
// index.js
import express from 'express';
import dotenv from 'dotenv';
import postRoutes from './src/routes/post.routes.js';

// Load environment variables from .env file
dotenv.config();

const app = express();
// Use the PORT from environment variables, with a fallback to 3000
const port = process.env.PORT || 3000;

app.use(express.json());

// Mount the post routes
app.use('/posts', postRoutes);

app.listen(port, () => {
    console.log(`Server is running on http://localhost:${port}`);
});
```

*   `dotenv.config()` reads your `.env` file, parses the contents, and assigns them to `process.env`.
*   We now read the port from `process.env.PORT`. The `|| 3000` is a fallback, which is good practice in case the variable isn't defined.

**4. Create a `.gitignore` File**

Your `.env` file might contain sensitive information in the future (like database credentials). It is specific to your machine and should **never** be committed to Git. Likewise, the `node_modules` directory contains thousands of files that can be easily re-installed by running `npm install`, so we don't need to track it.

*   Create a file named `.gitignore` in the **root** of your project.
*   Add the following lines to it:

    ```
    # Dependencies
    node_modules

    # Environment variables
    .env
    ```

This tells Git to ignore these files and directories.

---

### **Part 3: Practical Work - Basic Logging with `morgan`**

When developing an API, it's incredibly helpful to see a log of every incoming request in your console. This helps with debugging and understanding how your API is being used. The `morgan` package is an excellent tool for this.

**1. Install `morgan`**

In your terminal, run:

```bash
npm install morgan
```

**2. Add `morgan` as Middleware**

Middleware are functions that run for every request that comes into your Express server. We'll add `morgan` as a piece of middleware in `index.js`.

Update your `index.js` to include `morgan`:

```javascript
// index.js
import express from 'express';
import dotenv from 'dotenv';
import morgan from 'morgan'; // Import morgan
import postRoutes from './src/routes/post.routes.js';

// Load environment variables from .env file
dotenv.config();

const app = express();
// Use the PORT from environment variables, with a fallback to 3000
const port = process.env.PORT || 3000;

// Middlewares
app.use(morgan('dev')); // Use morgan for logging
app.use(express.json());

// Mount the post routes
app.use('/posts', postRoutes);

app.listen(port, () => {
    console.log(`Server is running on http://localhost:${port}`);
});
```

We've added `app.use(morgan('dev'))`. The `'dev'` string specifies a predefined logging format that is concise and colored for development use.

---

### **Part 4: Verification**

Let's see our changes in action!

1.  If your server is running, stop it by pressing `Ctrl + C` in the terminal.
2.  Restart the server:
    ```bash
    node index.js
    ```
    The startup message should still say it's running on port 3000, but now it's reading that value from your `.env` file.

3.  Now, make a request using Postman or `curl`. For example:
    ```bash
    curl http://localhost:3000/posts
    ```

4.  Look at your terminal where the server is running. You should see a new line of output from `morgan`, something like this:

    ```
    GET /posts 200 134 - 2.277 ms
    ```

This log tells you the HTTP method (`GET`), the path (`/posts`), the status code (`200`), the response size, and how long the request took. You've successfully added request logging!

---

### **Part 5: Challenges and Exercises**

Test your new knowledge with these challenges.

#### **Challenge 1: Environment-Specific Logging**

It's common to have more detailed logging in development but less in production.

1.  Add a new variable to your `.env` file: `NODE_ENV=development`.
2.  In `index.js`, use an `if` statement to check the value of `process.env.NODE_ENV`.
3.  If the environment is `'development'`, use the `morgan('dev')` logger. Otherwise (for production), don't use `morgan` at all. This prevents noisy logs in your production environment.

#### **Challenge 2: Different Morgan Formats**

The `morgan` package comes with several predefined formats besides `'dev'`.

1.  Look up the documentation for the `morgan` package on npmjs.com.
2.  Find the other available formats (like `'tiny'` or `'combined'`).
3.  Change the format in your `index.js` file and restart the server. Make a few requests and observe how the log output changes. The `'combined'` format mimics a standard Apache log format and is very common for production logging.

#### **Challenge 3: Centralized Configuration**

As your application grows, you might have many environment variables. It's a good practice to manage them in a single place.

1.  Create a new directory `src/config`.
2.  Inside it, create a file named `index.js`.
3.  In `src/config/index.js`, import `dotenv` and call `dotenv.config()`.
4.  Create and export an object that holds your configuration values, reading them from `process.env`.
    ```javascript
    // Example src/config/index.js
    import dotenv from 'dotenv';
    dotenv.config();

    const config = {
        port: process.env.PORT || 3000,
        nodeEnv: process.env.NODE_ENV || 'development'
    };

    export default config;
    ```
    5.  Refactor your main `index.js` to import this `config` object instead of accessing `process.env` directly. This keeps your main file cleaner and centralizes where configuration is handled.