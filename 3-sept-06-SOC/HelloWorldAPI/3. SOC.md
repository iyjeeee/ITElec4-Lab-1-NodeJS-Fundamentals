### **Lab: Separating Concerns in a Node.js Express Application**

Welcome to this hands-on lab where you'll learn a fundamental software engineering principle: **Separation of Concerns**. We'll take a simple Express.js application with all its code in one file and refactor it into a more organized, maintainable, and scalable structure.

#### **Prerequisites**

*   Basic understanding of JavaScript and Node.js.
*   Node.js and npm (or yarn) installed on your machine.
*   A code editor of your choice (e.g., VS Code).
*   A tool for making HTTP requests, like Postman or the `curl` command.

#### **Learning Objectives**

By the end of this lab, you will be able to:

*   Explain the concept of Separation of Concerns.
*   Structure a Node.js application with distinct layers for routing, controllers, and services.
*   Refactor existing code to adhere to this architectural pattern.
*   Understand the benefits of a well-organized codebase.

---

### **Part 1: Understanding the Problem - The Monolithic `app.js`**

Let's start with a typical "all-in-one" Express application. This is often how small projects or initial prototypes are built.

**1. Initial Setup**

First, let's create our project and the initial `app.js` file.

*   Create a new directory for your project:
    ```bash
    mkdir express-separation-of-concerns-lab
    cd express-separation-of-concerns-lab
    ```
*   Initialize a Node.js project:
    ```bash
    npm init -y
    ```
*   Install Express:
    ```bash
    npm install express
    ```
*   In your `package.json`, add `"type": "module"` to enable ES Modules. Your `package.json` should look something like this:
    ```json
    {
      "name": "express-separation-of-concerns-lab",
      "version": "1.0.0",
      "description": "",
      "main": "index.js",
      "type": "module",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
      },
      "keywords": [],
      "author": "",
      "license": "ISC",
      "dependencies": {
        "express": "^4.18.2"
      }
    }
    ```
*   Create a file named `app.js` and add the following code:

    ```javascript
    // app.js
    import express from 'express';

    const app = express();
    const port = 3000;

    app.use(express.json()); // Middleware to parse JSON bodies

    // In-memory "database"
    let posts = [
        { id: 1, title: 'First Post', content: 'This is the first post.' },
        { id: 2, title: 'Second Post', content: 'This is the second post.' }
    ];
    let nextId = 3;

    // POST /posts (adds a new post to the array)
    app.post('/posts', (req, res) => {
        const { title, content } = req.body;
        if (!title || !content) {
            return res.status(400).json({ message: 'Title and content are required.' });
        }
        const newPost = { id: nextId++, title, content };
        posts.push(newPost);
        res.status(201).json(newPost);
    });

    // GET /posts (returns the full array)
    app.get('/posts', (req, res) => {
        res.json(posts);
    });

    // GET /posts/:id (finds and returns a single post)
    app.get('/posts/:id', (req, res) => {
        const postId = parseInt(req.params.id, 10);
        const post = posts.find(p => p.id === postId);
        if (!post) {
            return res.status(404).json({ message: 'Post not found.' });
        }
        res.json(post);
    });

    // PUT /posts/:id (finds and updates a post)
    app.put('/posts/:id', (req, res) => {
        const postId = parseInt(req.params.id, 10);
        const postIndex = posts.findIndex(p => p.id === postId);
        if (postIndex === -1) {
            return res.status(404).json({ message: 'Post not found.' });
        }
        const { title, content } = req.body;
        posts[postIndex] = { ...posts[postIndex], title: title || posts[postIndex].title, content: content || posts[postIndex].content };
        res.json(posts[postIndex]);
    });

    // DELETE /posts/:id (removes a post from the array)
    app.delete('/posts/:id', (req, res) => {
        const postId = parseInt(req.params.id, 10);
        const postIndex = posts.findIndex(p => p.id === postId);
        if (postIndex === -1) {
            return res.status(404).json({ message: 'Post not found.' });
        }
        posts.splice(postIndex, 1);
        res.status(204).send();
    });

    app.listen(port, () => {
        console.log(`Server is running on http://localhost:${port}`);
    });
    ```

**2. Test the Current Application**

*   Run your server:
    ```bash
    node app.js
    ```
*   Use Postman or `curl` to test the endpoints:
    *   `GET http://localhost:3000/posts`
    *   `POST http://localhost:3000/posts` with a JSON body like `{"title": "A New Post", "content": "Some interesting content."}`
    *   `GET http://localhost:3000/posts/1`
    *   `PUT http://localhost:3000/posts/1` with a JSON body like `{"title": "Updated Title"}`
    *   `DELETE http://localhost:3000/posts/2`

While this works perfectly fine for a small application, imagine if we had more resources (like comments, users, etc.) and more complex logic. This single file would become very long and difficult to manage.

---

### **Part 2: Refactoring for Separation of Concerns**

Now, let's refactor our application into three distinct layers:

*   **Routes:** Define the API endpoints and which controller functions handle them.
*   **Controllers:** Handle the incoming request and outgoing response. They orchestrate the flow of data but don't contain the core business logic.
*   **Services:** Contain the core business logic and data manipulation. They are not aware of the request and response objects.

**1. Create the Directory Structure**

*   Create a `src` directory.
*   Inside `src`, create `routes`, `controllers`, and `services` subdirectories.
*   Rename `app.js` to `index.js` and move it to the root of your project.

Your project structure should now look like this:

```
/express-separation-of-concerns-lab
|-- /src
|   |-- /controllers
|   |-- /routes
|   |-- /services
|-- index.js
|-- package.json
|-- package-lock.json
```

**2. The Service Layer: `src/services/post.service.js`**

This layer will manage our in-memory `posts` array and the logic for interacting with it.

*   Create a new file: `src/services/post.service.js`
*   Add the following code. Notice how these functions are pure data manipulation and don't know anything about `req` or `res`.

    ```javascript
    // src/services/post.service.js

    let posts = [
        { id: 1, title: 'First Post', content: 'This is the first post.' },
        { id: 2, title: 'Second Post', content: 'This is the second post.' }
    ];
    let nextId = 3;

    export const getAllPosts = () => {
        return posts;
    };

    export const getPostById = (id) => {
        return posts.find(p => p.id === id);
    };

    export const createPost = (postData) => {
        const newPost = { id: nextId++, ...postData };
        posts.push(newPost);
        return newPost;
    };

    export const updatePost = (id, postData) => {
        const postIndex = posts.findIndex(p => p.id === id);
        if (postIndex === -1) {
            return null;
        }
        posts[postIndex] = { ...posts[postIndex], ...postData };
        return posts[postIndex];
    };

    export const deletePost = (id) => {
        const postIndex = posts.findIndex(p => p.id === id);
        if (postIndex === -1) {
            return false;
        }
        posts.splice(postIndex, 1);
        return true;
    };
    ```

**3. The Controller Layer: `src/controllers/post.controller.js`**

This layer acts as the middleman between the routes and the services. It handles the HTTP-specific parts.

*   Create a new file: `src/controllers/post.controller.js`
*   Add the following code. This file will import the service functions and use them to handle requests.

    ```javascript
    // src/controllers/post.controller.js
    import * as postService from '../services/post.service.js';

    export const getAllPosts = (req, res) => {
        const posts = postService.getAllPosts();
        res.json(posts);
    };

    export const getPostById = (req, res) => {
        const postId = parseInt(req.params.id, 10);
        const post = postService.getPostById(postId);
        if (!post) {
            return res.status(404).json({ message: 'Post not found.' });
        }
        res.json(post);
    };

    export const createPost = (req, res) => {
        const { title, content } = req.body;
        if (!title || !content) {
            return res.status(400).json({ message: 'Title and content are required.' });
        }
        const newPost = postService.createPost({ title, content });
        res.status(201).json(newPost);
    };

    export const updatePost = (req, res) => {
        const postId = parseInt(req.params.id, 10);
        const post = postService.updatePost(postId, req.body);
        if (!post) {
            return res.status(404).json({ message: 'Post not found.' });
        }
        res.json(post);
    };

    export const deletePost = (req, res) => {
        const postId = parseInt(req.params.id, 10);
        const success = postService.deletePost(postId);
        if (!success) {
            return res.status(404).json({ message: 'Post not found.' });
        }
        res.status(204).send();
    };
    ```

**4. The Router Layer: `src/routes/post.routes.js`**

This file defines the endpoints for our application and maps them to the controller functions.

*   Create a new file: `src/routes/post.routes.js`
*   Add the following code:

    ```javascript
    // src/routes/post.routes.js
    import { Router } from 'express';
    import * as postController from '../controllers/post.controller.js';

    const router = Router();

    router.get('/', postController.getAllPosts);
    router.post('/', postController.createPost);
    router.get('/:id', postController.getPostById);
    router.put('/:id', postController.updatePost);
    router.delete('/:id', postController.deletePost);

    export default router;
    ```

**5. The Main `index.js` File**

Now, let's clean up our main `index.js` file. Its primary responsibilities are to set up the Express server and mount our routes.

*   Open `index.js` and replace its content with the following:

    ```javascript
    // index.js
    import express from 'express';
    import postRoutes from './src/routes/post.routes.js';

    const app = express();
    const port = 3000;

    app.use(express.json());

    // Mount the post routes
    app.use('/posts', postRoutes);

    app.listen(port, () => {
        console.log(`Server is running on http://localhost:${port}`);
    });
    ```

Notice how clean and readable this file has become. It's clear that any request to `/posts` will be handled by the `postRoutes`.

**6. Test the Refactored Application**

*   Run your server:
    ```bash
    node index.js
    ```
*   Use Postman or `curl` to test all the endpoints again. They should all work exactly as before.

Congratulations! You have successfully refactored your application to follow the principle of Separation of Concerns.

---

### **Part 3: Challenges and Exercises**

Now that you've completed the lab, here are some challenges to solidify your understanding.

#### **Challenge 1: Add a New Endpoint**

*   Add a `PATCH` endpoint to `/posts/:id` that allows for partial updates to a post (e.g., updating only the title or only the content).
*   You will need to:
    1.  Create a new function in `post.service.js`.
    2.  Create a corresponding controller function in `post.controller.js`.
    3.  Add the new route definition in `post.routes.js`.

#### **Challenge 2: Create a New Resource**

*   Add a new resource called "comments". A comment should have an `id`, `text`, and a `postId` to associate it with a post.
*   You will need to:
    1.  Create `src/services/comment.service.js`.
    2.  Create `src/controllers/comment.controller.js`.
    3.  Create `src/routes/comment.routes.js`.
    4.  Mount the new comment routes in `index.js` under `/comments`.
*   Implement the following endpoints for comments:
    *   `GET /comments` (get all comments)
    *   `GET /posts/:postId/comments` (get all comments for a specific post)
    *   `POST /posts/:postId/comments` (create a new comment for a post)


This lab provides a solid foundation for building more complex and maintainable Node.js applications. By separating concerns, you make your code easier to read, debug, and extend.

---

### **Answer for Challenge 1: Add a New `PATCH` Endpoint**

This challenge requires adding a new endpoint `PATCH /posts/:id` for partial updates. This involves updating the service, controller, and router files.

<details>
<summary>Click to see the solution for Challenge 1</summary>

#### **1. Update the Service Layer (`src/services/post.service.js`)**

We need a new function that finds a post and merges the existing data with the new data, rather than completely replacing it.

```javascript
// src/services/post.service.js

let posts = [
    { id: 1, title: 'First Post', content: 'This is the first post.' },
    { id: 2, title: 'Second Post', content: 'This is the second post.' }
];
let nextId = 3;

export const getAllPosts = () => {
    return posts;
};

export const getPostById = (id) => {
    return posts.find(p => p.id === id);
};

export const createPost = (postData) => {
    const newPost = { id: nextId++, ...postData };
    posts.push(newPost);
    return newPost;
};

// This is the old update function for PUT
export const updatePost = (id, postData) => {
    const postIndex = posts.findIndex(p => p.id === id);
    if (postIndex === -1) {
        return null;
    }
    // For PUT, we can keep it as is, but for PATCH, we need to merge
    posts[postIndex] = { ...posts[postIndex], title: postData.title, content: postData.content };
    return posts[postIndex];
};

// *** NEW FUNCTION FOR PATCH ***
export const partiallyUpdatePost = (id, updates) => {
    const postIndex = posts.findIndex(p => p.id === id);
    if (postIndex === -1) {
        return null; // Post not found
    }
    // Merge the existing post with the updates
    const updatedPost = { ...posts[postIndex], ...updates };
    posts[postIndex] = updatedPost;
    return updatedPost;
};

export const deletePost = (id) => {
    const postIndex = posts.findIndex(p => p.id === id);
    if (postIndex === -1) {
        return false;
    }
    posts.splice(postIndex, 1);
    return true;
};
```

#### **2. Update the Controller Layer (`src/controllers/post.controller.js`)**

Add a new controller function that calls our new service method.

```javascript
// src/controllers/post.controller.js
import * as postService from '../services/post.service.js';

// ... (keep getAllPosts, getPostById, createPost, updatePost)

// *** NEW CONTROLLER FUNCTION FOR PATCH ***
export const partiallyUpdatePost = (req, res) => {
    const postId = parseInt(req.params.id, 10);
    // req.body will contain the fields to update, e.g., { title: "New Title" }
    const post = postService.partiallyUpdatePost(postId, req.body);
    if (!post) {
        return res.status(404).json({ message: 'Post not found.' });
    }
    res.json(post);
};

export const deletePost = (req, res) => {
    // ... (keep this function as is)
};
```

#### **3. Update the Router Layer (`src/routes/post.routes.js`)**

Finally, add the new route definition to map the endpoint to the controller.

```javascript
// src/routes/post.routes.js
import { Router } from 'express';
import * as postController from '../controllers/post.controller.js';

const router = Router();

router.get('/', postController.getAllPosts);
router.post('/', postController.createPost);
router.get('/:id', postController.getPostById);
router.put('/:id', postController.updatePost);

// *** NEW ROUTE DEFINITION FOR PATCH ***
router.patch('/:id', postController.partiallyUpdatePost);

router.delete('/:id', postController.deletePost);

export default router;
```

**To Test:** Run `node index.js` and make a `PATCH` request to `http://localhost:3000/posts/1` with a JSON body like `{"content": "This content has been partially updated."}`. You should see only the content change, while the title remains the same.

</details>

---

### **Answer for Challenge 2: Create a New "Comments" Resource**

This challenge involves creating a complete set of files for a new "comments" resource and integrating it into the main application.

<details>
<summary>Click to see the solution for Challenge 2</summary>

#### **1. Create the Service Layer (`src/services/comment.service.js`)**

This file will manage the comments data.

```javascript
// src/services/comment.service.js

// In-memory "database" for comments
let comments = [
    { id: 1, text: 'Great first post!', postId: 1 },
    { id: 2, text: 'I agree, very insightful.', postId: 1 },
    { id: 3, text: 'This is a comment on the second post.', postId: 2 },
];
let nextId = 4;

// We need access to posts to ensure a post exists before adding a comment
import { getPostById } from './post.service.js';

export const getAllComments = () => {
    return comments;
};

export const getCommentsByPostId = (postId) => {
    return comments.filter(c => c.postId === postId);
};

export const createComment = (postId, commentData) => {
    // Check if the post actually exists before creating a comment for it
    const post = getPostById(postId);
    if (!post) {
        return null; // Or throw an error
    }
    const newComment = { id: nextId++, postId, ...commentData };
    comments.push(newComment);
    return newComment;
};
```

#### **2. Create the Controller Layer (`src/controllers/comment.controller.js`)**

This file handles the request and response logic for comments.

```javascript
// src/controllers/comment.controller.js
import * as commentService from '../services/comment.service.js';

export const getAllComments = (req, res) => {
    const comments = commentService.getAllComments();
    res.json(comments);
};

export const getCommentsByPostId = (req, res) => {
    const postId = parseInt(req.params.postId, 10);
    const comments = commentService.getCommentsByPostId(postId);
    res.json(comments);
};

export const createCommentForPost = (req, res) => {
    const postId = parseInt(req.params.postId, 10);
    const { text } = req.body;

    if (!text) {
        return res.status(400).json({ message: 'Comment text is required.' });
    }

    const newComment = commentService.createComment(postId, { text });

    if (!newComment) {
        return res.status(404).json({ message: 'Post not found.' });
    }

    res.status(201).json(newComment);
};
```

#### **3. Create the Router Layer (`src/routes/comment.routes.js`)**

This router will handle the top-level `/comments` endpoint.

```javascript
// src/routes/comment.routes.js
import { Router } from 'express';
import * as commentController from '../controllers/comment.controller.js';

const router = Router();

// Route for GET /comments
router.get('/', commentController.getAllComments);

export default router;
```

#### **4. Update the Post Router (`src/routes/post.routes.js`)**

To handle the nested routes (`/posts/:postId/comments`), it's best practice to add them to the `post.routes.js` file since they are contextually related to a specific post.

```javascript
// src/routes/post.routes.js
import { Router } from 'express';
import * as postController from '../controllers/post.controller.js';
// *** IMPORT THE COMMENT CONTROLLER ***
import * as commentController from '../controllers/comment.controller.js';

const router = Router();

// --- Post Routes ---
router.get('/', postController.getAllPosts);
router.post('/', postController.createPost);
router.get('/:id', postController.getPostById);
router.put('/:id', postController.updatePost);
router.patch('/:id', postController.partiallyUpdatePost); // From Challenge 1
router.delete('/:id', postController.deletePost);

// --- Nested Comment Routes ---
// GET /posts/:postId/comments
router.get('/:postId/comments', commentController.getCommentsByPostId);
// POST /posts/:postId/comments
router.post('/:postId/comments', commentController.createCommentForPost);

export default router;
```

#### **5. Update the Main `index.js` File**

Finally, mount the new `commentRoutes` in your main server file.

```javascript
// index.js
import express from 'express';
import postRoutes from './src/routes/post.routes.js';
// *** IMPORT THE NEW COMMENT ROUTES ***
import commentRoutes from './src/routes/comment.routes.js';

const app = express();
const port = 3000;

app.use(express.json());

// Mount the post routes
app.use('/posts', postRoutes);

// *** MOUNT THE NEW COMMENT ROUTES ***
app.use('/comments', commentRoutes);

app.listen(port, () => {
    console.log(`Server is running on http://localhost:${port}`);
});
```

**To Test:**
1.  Run `node index.js`.
2.  `GET http://localhost:3000/comments` to see all comments.
3.  `GET http://localhost:3000/posts/1/comments` to see only comments for the first post.
4.  `POST http://localhost:3000/posts/2/comments` with a body `{"text": "This is a new comment!"}` to add a new comment to the second post.

</details>
