### **Lab: User Login with JWT and Middleware**

We have successfully implemented a secure registration system, but a user who registers still can't do anything special. We have no way of knowing who is making a request. How can we allow a logged-in user to create a blog post *as themselves* without them needing to send their password with every single request?

The answer is stateless authentication using JSON Web Tokens (JWT). In this lab, we will build a login endpoint that issues a secure token, and then create a special "gatekeeper" function—known as middleware—to protect our routes, ensuring only authenticated users can perform certain actions.

#### **Prerequisites**

*   Completion of the "User Registration and Password Security" lab.
*   Your MySQL database server is running.
*   An API client like Postman or Insomnia to easily manage authorization headers.

#### **Learning Objectives**

By the end of this lab, you will be able to:

*   Understand the concept of stateless authentication with JWTs.
*   Build a secure login endpoint that compares hashed passwords.
*   Generate and sign a JSON Web Token containing user data.
*   Create and apply Express middleware to protect specific API routes.
*   Refactor controllers to use authenticated user data from a request.

---

### **Part 1: Core Concepts**

**1. What is Stateless Authentication?**

Imagine a security guard who has no memory. Every time you approach a door, you have to show them your ID card. The guard looks at your ID, verifies it's legitimate, and lets you through. They don't need to remember you from five minutes ago. The ID card contains everything they need to know.

This is **stateless authentication**. The server (the security guard) does not need to keep a record or "session" of who is logged in. The client sends a verifiable "ID card"—the JWT—with every request to a protected resource. This makes our application highly scalable.

**2. What is a JSON Web Token (JWT)?**

A JWT is that secure ID card. It's a compact, URL-safe string of characters that is digitally signed. It consists of three parts separated by dots: `header.payload.signature`.

*   **Header:** Contains metadata, like the algorithm used for the signature.
*   **Payload:** Contains the "claims" or data we want to send. For example, `{ "userId": 1, "username": "testuser" }`. **This data is encoded, not encrypted, so you should never put sensitive information like passwords here.**
*   **Signature:** This is the magic. The header and payload are combined with a secret key (that only the server knows) and hashed. If a user tries to tamper with the payload (e.g., change their `userId` to someone else's), the signature will no longer be valid. This is how the server verifies the token's integrity.

---

### **Part 2: Setup and Configuration**

**1. Install `jsonwebtoken` and `dotenv`**

*   `jsonwebtoken` is the library we'll use to create and verify JWTs.
*   `dotenv` is a utility that loads environment variables from a `.env` file into `process.env`. This is crucial for keeping our JWT secret key out of our source code.

Open your terminal and run:

```bash
npm install jsonwebtoken dotenv
```

**2. Create a `.env` File for Your Secret Key**

A secret key is a long, random string that is used to sign your tokens. If this key is ever exposed, anyone can create valid tokens for your application. **It must be kept secret.**

*   In the root directory of your project, create a new file named `.env`.
*   Add the following line to the file. You can replace the value with your own long, random, and hard-to-guess string.

```
JWT_SECRET=this-is-a-very-long-and-super-secret-key-for-my-blog-app
```

**3. Configure `dotenv` in `index.js`**

We need to tell our application to load the variables from our `.env` file.

*   Open `index.js` and add the following lines at the very top of the file.

```javascript
// index.js
import dotenv from 'dotenv';
dotenv.config(); // This loads the .env file

import express from 'express';
// ... rest of your imports
```

---

### **Part 3: Building the Login Endpoint**

Now we'll build the logic that allows a user to log in.

**1. Update the User Service (`user.service.js`)**

We need a new function that finds a user, compares their password, and generates a token.

*   Open `src/services/user.service.js` and add the following function.

```javascript
// src/services/user.service.js
import pool from '../config/db.js';
import { ApiError } from '../utils/ApiError.js';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken'; // IMPORT JWT

// ... (keep your registerUser, getUserById, getAllUsers functions)

export const loginUser = async (loginData) => {
    const { email, password } = loginData;

    // 1. Find the user by email
    const [rows] = await pool.query('SELECT * FROM users WHERE email = ?', [email]);
    if (rows.length === 0) {
        throw new ApiError(401, "Invalid credentials"); // Use a generic error
    }
    const user = rows[0];

    // 2. Compare the provided password with the stored hash
    const isPasswordMatch = await bcrypt.compare(password, user.password);
    if (!isPasswordMatch) {
        throw new ApiError(401, "Invalid credentials"); // Same generic error
    }

    // 3. If password matches, generate a JWT
    const payload = {
        id: user.id,
        username: user.username,
        email: user.email
    };

    const token = jwt.sign(payload, process.env.JWT_SECRET, {
        expiresIn: '1h' // Token will expire in 1 hour
    });

    return token;
};
```

> #### **Code Explanation**
> *   **Security Note:** We throw the exact same "Invalid credentials" error whether the user doesn't exist or the password is wrong. This prevents "user enumeration," where an attacker could guess valid email addresses based on the error message.
> *   `bcrypt.compare(password, user.password)`: This is the secure way to check the password. It takes the plain-text password from the login attempt, hashes it with the salt from the stored `user.password`, and sees if the results match.
> *   `jwt.sign(payload, secret, options)`: This creates the token.
>     *   `payload`: The data we want to store in the token.
>     *   `process.env.JWT_SECRET`: The secret key we defined in our `.env` file.
>     *   `expiresIn`: A best practice to automatically invalidate tokens after a certain period.

**2. Update the Auth Controller and Routes**

*   Open `src/controllers/auth.controller.js` and add the new login controller function.

```javascript
// src/controllers/auth.controller.js
// ... (imports and registerUser function)

export const loginUser = asyncHandler(async (req, res) => {
    const token = await userService.loginUser(req.body);
    res.status(200).json(new ApiResponse(200, { token }, "User logged in successfully"));
});
```

*   Open `src/routes/auth.routes.js` to add the new login route and its validator.

```javascript
// src/routes/auth.routes.js
import { Router } from 'express';
import * as authController from '../controllers/auth.controller.js';
// We'll add a new validator for login
import { validateRegistration, validateLogin } from '../middlewares/validator.middleware.js';

const router = Router();

router.post('/register', validateRegistration, authController.registerUser);
router.post('/login', authController.loginUser); // ADD THIS ROUTE

export default router;
```

---

### **Part 4: Creating and Applying the Authentication Middleware**

This middleware will be our "gatekeeper." It will check for a valid JWT on incoming requests.

**1. Create the Auth Middleware (`src/middlewares/auth.middleware.js`)**

*   Create a new file: `src/middlewares/auth.middleware.js`.

```javascript
// src/middlewares/auth.middleware.js
import jwt from 'jsonwebtoken';
import { ApiError } from '../utils/ApiError.js';
import asyncHandler from 'express-async-handler';
import { getUserById } from '../services/user.service.js';

export const authMiddleware = asyncHandler(async (req, res, next) => {
    let token;

    // Check for the token in the Authorization header
    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
        try {
            // Get token from header (e.g., "Bearer <token>")
            token = req.headers.authorization.split(' ')[1];

            // Verify the token
            const decoded = jwt.verify(token, process.env.JWT_SECRET);

            // Get the user from the token's payload (id) and attach it to the request
            // We fetch from DB to ensure the user still exists
            req.user = await getUserById(decoded.id);

            next(); // Move to the next middleware or controller
        } catch (error) {
            throw new ApiError(401, "Not authorized, token failed");
        }
    }

    if (!token) {
        throw new ApiError(401, "Not authorized, no token");
    }
});
```

**2. Protect the Post Creation Route**

Now, let's use our new middleware to protect a route. A user must be logged in to create a post.

*   Open `src/routes/post.routes.js`.

```javascript
// src/routes/post.routes.js
import { Router } from 'express';
import * as postController from '../controllers/post.controller.js';
import { validatePost } from '../middlewares/validator.middleware.js';
import { authMiddleware } from '../middlewares/auth.middleware.js'; // IMPORT

const router = Router();

// ... (GET routes can remain public)
router.get('/', postController.getAllPosts);
router.get('/:id', postController.getPostById);

// PROTECT THIS ROUTE: A user must be logged in to create a post
router.post('/', authMiddleware, validatePost, postController.createPost);

export default router;
```

---

### **Part 5: Refactoring Post Creation to Use the Authenticated User**

Because our `authMiddleware` attaches the logged-in user to `req.user`, we no longer need the client to manually send an `authorId` in the request body. This is more secure and convenient!

**1. Update the Post Controller (`post.controller.js`)**

```javascript
// src/controllers/post.controller.js
// ... (imports)

export const createPost = asyncHandler(async (req, res) => {
    // The authorId now comes from the authenticated user attached by the middleware
    const authorId = req.user.id;
    const postData = req.body;

    const newPost = await postService.createPost(postData, authorId); // Pass authorId separately
    res.status(201).json(new ApiResponse(201, newPost, "Post created successfully"));
});

// ... (other controller functions)
```

**2. Update the Post Service (`post.service.js`)**

```javascript
// src/services/post.service.js
// ... (imports)

// Update the function to accept authorId as a direct argument
export const createPost = async (postData, authorId) => {
    const { title, content } = postData; // No longer need authorId from here
    try {
        const [result] = await pool.query(
            'INSERT INTO posts (title, content, authorId) VALUES (?, ?, ?)',
            [title, content, authorId] // Use the authorId from the argument
        );
        const newPost = await getPostById(result.insertId);
        return newPost;
    } catch (error) {
        // ... (error handling remains the same)
    }
};

// ...
```

**3. Update the Post Validator (`validator.middleware.js`)**

Since `authorId` is no longer in the body, we must remove it from the validation rules.

```javascript
// src/middlewares/validator.middleware.js
// ... (imports)

export const validatePost = [
    body('title').trim().notEmpty().withMessage('Title is required.'),
    body('content').trim().notEmpty().withMessage('Content is required.'),

    // REMOVE THE AUTHORID VALIDATION
    // body('authorId')...

    (req, res, next) => {
        // ...
    },
];
```

---

### **Part 6: Testing the Full Authentication Flow**

1.  **Start your server:** `node index.js`.
2.  **Register a User:** `POST /api/auth/register` if you don't have one.
3.  **Login:** Make a `POST` request to `http://localhost:3000/api/auth/login` with the user's credentials.
    ```json
    {
        "email": "test@example.com",
        "password": "password123"
    }
    ```
    You will get a JWT back in the response. Copy this long token string.
4.  **Try to Create a Post (No Token):** Make a `POST` request to `http://localhost:3000/api/posts` with a post title and content, but **no authorization header**. You should receive a `401 Unauthorized` error.
5.  **Create a Post (With Token):** Now, make the same `POST` request again, but this time, add an `Authorization` header. In Postman, this is under the "Authorization" tab, type "Bearer Token", and paste your JWT in the token field.
    *   **Header:** `Authorization: Bearer <your_copied_jwt_here>`
    *   **Body:**
        ```json
        {
            "title": "My Authenticated Post",
            "content": "This was created by a logged-in user!"
        }
        ```
    This time, you should get a `201 Created` response. Check your database, and you will see the `authorId` on the new post correctly corresponds to the user you logged in as.

Congratulations! You have now implemented a complete, secure authentication and authorization flow using modern, stateless JWTs and protected your API with custom middleware.