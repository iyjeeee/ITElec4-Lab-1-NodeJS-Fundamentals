### **Lab: User Registration and Password Security**

So far, we have created users, posts, and comments, but our application has a major security vulnerability: we aren't handling passwords. Anyone could impersonate a user, and if we were storing passwords, they would be in plain text.

In this lab, we will introduce proper user registration by implementing one of the most critical features in web development: secure password hashing. We will create a dedicated authentication endpoint and ensure that no plain-text passwords ever touch our database.

#### **Prerequisites**

*   Completion of the "Migrating the Comments Resource to the Database" lab.
*   Your MySQL database server is running.

#### **Learning Objectives**

By the end of this lab, you will be able to:

*   Clearly distinguish between Authentication and Authorization.
*   Explain why passwords must always be hashed.
*   Use the `bcrypt` library to securely hash and compare passwords.
*   Implement a secure user registration endpoint.
*   Modify a database schema to securely store password hashes.

---

### **Part 1: Core Security Concepts**

Before we write any code, it's essential to understand two fundamental security concepts.

**1. Authentication vs. Authorization**

*   **Authentication** is the process of verifying who you are. When you log in with a username and password, the system **authenticates** you. It confirms that you are the user you claim to be. This is the focus of today's lab.
*   **Authorization** is the process of verifying what you are allowed to do. Once you are authenticated, the system might check if you are an "admin" or a "standard user" before letting you access a certain feature. This determines your permissions. We will tackle this in a future lab.

In short: **Authentication is proving your identity; Authorization is checking your permissions.**

**2. Why We MUST Hash Passwords**

Storing a user's password in plain text (`"myPassword123"`) in the database is extremely dangerous. If a hacker ever gains access to your database, they will have the passwords for every single user.

To prevent this, we use **one-way hashing**.

*   A hashing algorithm (like `bcrypt`) takes an input (the password) and transforms it into a long, unique, and irreversible string of characters called a **hash**.
*   **One-Way:** You can easily generate the hash from the password, but you cannot generate the password from the hash.
*   **Salt:** `bcrypt` automatically includes a "salt"—a random piece of data—before hashing. This ensures that even if two users have the exact same password, their stored hashes will be completely different.

When a user tries to log in, we don't "un-hash" the password in the database. Instead, we take the password they just provided, hash it using the same algorithm, and then **compare the new hash to the one in the database**. If they match, the password is correct.

---

### **Part 2: Setup and Database Modification**

**1. Install `bcrypt`**

This is the industry-standard library for hashing passwords in Node.js. Open your terminal in the project directory and run:

```bash
npm install bcrypt
```

**2. Add a `password` Column to the `users` Table**

We need a place to store the generated password hash. Execute the following SQL command in your MySQL client.

```sql
-- Make sure you are using the correct database
USE blogdatabase;

ALTER TABLE users
ADD COLUMN password VARCHAR(255) NOT NULL;
```

> #### **Code Explanation**
> *   `VARCHAR(255)`: A `bcrypt` hash is 60 characters long, but we use 255 to be safe and allow for future upgrades to stronger hashing algorithms that might produce longer hashes.
> *   `NOT NULL`: A user cannot exist without a password.

---

### **Part 3: Implementing the Secure Registration Flow**

We will now refactor our user creation logic into a secure registration endpoint.

**1. Create a User Registration Validator**

We need to validate that a password is included during registration.

*   Open `src/middlewares/validator.middleware.js` and add a new exported validator.

```javascript
// src/middlewares/validator.middleware.js
import { body, validationResult } from 'express-validator';
// ... (keep your other validators)

// ADD THIS NEW VALIDATOR
export const validateRegistration = [
    body('username')
        .trim()
        .notEmpty()
        .withMessage('Username is required.'),
    
    body('email')
        .isEmail()
        .withMessage('A valid email is required.'),

    body('password')
        .isLength({ min: 6 })
        .withMessage('Password must be at least 6 characters long.'),
    
    // This part remains the same for all validators
    (req, res, next) => {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({ success: false, errors: errors.array() });
        }
        next();
    },
];
```

**2. Update the User Service to Hash Passwords**

This is the most critical step. We will modify `user.service.js` to handle the new `password` field and hash it before saving.

*   Open `src/services/user.service.js` and update it as follows.

```javascript
// src/services/user.service.js
import pool from '../config/db.js';
import { ApiError } from '../utils/ApiError.js';
import bcrypt from 'bcrypt'; // IMPORT BCRYPT

// This function will now be specifically for registration
export const registerUser = async (userData) => {
    const { username, email, password } = userData; // Destructure password
    try {
        // HASH THE PASSWORD
        const saltRounds = 10; // The cost factor for hashing
        const hashedPassword = await bcrypt.hash(password, saltRounds);

        const [result] = await pool.query(
            // Use the new password column
            'INSERT INTO users (username, email, password) VALUES (?, ?, ?)',
            // Store the HASHED password, not the original
            [username, email, hashedPassword]
        );

        // Fetch the user, but OMIT the password from the return data
        const newUser = await getUserById(result.insertId);
        return newUser;

    } catch (error) {
        if (error.code === 'ER_DUP_ENTRY') {
            throw new ApiError(409, "Username or email already exists.");
        }
        throw error;
    }
};

export const getUserById = async (id) => {
    // IMPORTANT: Exclude the password hash when fetching user data
    const [rows] = await pool.query('SELECT id, username, email, createdAt FROM users WHERE id = ?', [id]);
    if (rows.length === 0) {
        throw new ApiError(404, "User not found");
    }
    return rows[0];
};

export const getAllUsers = async () => {
    // IMPORTANT: Exclude the password hash here too
    const [users] = await pool.query('SELECT id, username, email, createdAt FROM users');
    return users;
};
```

> #### **Code Explanation**
> *   `import bcrypt from 'bcrypt';`: We import the library we just installed.
> *   `const hashedPassword = await bcrypt.hash(password, 10);`: This is the magic. We call `bcrypt.hash`, passing in the plain-text password from the user and a "salt rounds" number. `10` is a good default. This process is asynchronous.
> *   `INSERT INTO users (..., password)`: We've updated the query to include the new column.
> *   `VALUES (..., hashedPassword)`: We insert the **hashed password**, never the original.
> *   **Security Best Practice:** We have updated `getUserById` and `getAllUsers` to explicitly select columns and **omit the password column**. You should never send a password hash back to the client in an API response.

**3. Create an Authentication Controller and Routes**

It's good practice to group authentication-related endpoints (like register, login, logout) together. We'll create a new controller and route file for this.

*   Create a new file: `src/controllers/auth.controller.js`.

```javascript
// src/controllers/auth.controller.js
import * as userService from '../services/user.service.js';
import { ApiResponse } from '../utils/ApiResponse.js';
import asyncHandler from 'express-async-handler';

export const registerUser = asyncHandler(async (req, res) => {
    // The service now handles password hashing
    const newUser = await userService.registerUser(req.body);
    res.status(201).json(new ApiResponse(201, newUser, "User registered successfully"));
});

// We will add a loginUser function here in the next lab
```

*   Create a new file: `src/routes/auth.routes.js`.

```javascript
// src/routes/auth.routes.js
import { Router } from 'express';
import * as authController from '../controllers/auth.controller.js';
import { validateRegistration } from '../middlewares/validator.middleware.js';

const router = Router();

// Define the registration endpoint
router.post('/register', validateRegistration, authController.registerUser);

export default router;
```

**4. Mount the New Auth Routes in `index.js`**

Finally, let's tell our Express app to use these new routes. We will also remove the old user creation route.

*   Update `src/routes/user.routes.js` to remove user creation. This router will now only be for fetching user data.

```javascript
// src/routes/user.routes.js
import { Router } from 'express';
import * as userController from '../controllers/user.controller.js';
// We no longer create users from this route file
// import * as userController from '../controllers/user.controller.js';

const router = Router();

// router.post('/', userController.createUser); // REMOVE THIS LINE
router.get('/', userController.getAllUsers);
router.get('/:id', userController.getUserById);

export default router;
```

*   Update `index.js` to mount the new auth routes.

```javascript
// index.js
// ... (imports)
import postRoutes from './src/routes/post.routes.js';
import userRoutes from './src/routes/user.routes.js';
import commentRoutes from './src/routes/comment.routes.js';
import authRoutes from './src/routes/auth.routes.js'; // IMPORT
// ... (more imports)

// ... (app setup)

// Mount the routes with an /api prefix
app.use('/api/auth', authRoutes); // MOUNT
app.use('/api/posts', postRoutes);
app.use('/api/users', userRoutes);
app.use('/api/comments', commentRoutes);

app.use(errorHandler);

// ... (app.listen)
```

---

### **Part 4: Testing the Secure Endpoint**

1.  **Start your server:** `node index.js`
2.  **Register a New User:** Make a `POST` request to the new endpoint: `http://localhost:3000/api/auth/register`. Use a JSON body that includes the password:
    ```json
    {
        "username": "testuser",
        "email": "test@example.com",
        "password": "password123"
    }
    ```
3.  **Check the Response:** You should get a `201 Created` response with the new user's data. Crucially, **the response body should NOT contain the password hash**.
    ```json
    {
        "statusCode": 201,
        "data": {
            "id": 1,
            "username": "testuser",
            "email": "test@example.com",
            "createdAt": "..."
        },
        "message": "User registered successfully",
        "success": true
    }
    ```
4.  **Verify in the Database:** This is the most important test. Open your MySQL client and run `SELECT username, email, password FROM users;`. You will see that the value in the `password` column is **not** `"password123"`. It will be a long string of random-looking characters, something like this:
    `$2b$10$f9a/u2Y.y3a...`

    This confirms your hashing is working correctly!

Congratulations! You have successfully implemented a secure user registration system, a fundamental building block for any real-world application that requires user accounts.