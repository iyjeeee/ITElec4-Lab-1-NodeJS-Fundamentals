### **Lab: The Photo API - Handling File Uploads**

Our blog API is becoming quite powerful, but it's still missing a key feature of modern web applications: the ability to handle rich media. A blog post is much more engaging with images.

In this lab, we will build a dedicated API for photos. This involves learning how to handle a new type of request data, `multipart/form-data`, and using a powerful middleware called `multer` to process file uploads. We will save the uploaded images to our server's filesystem and store a reference to them in our database, all while ensuring that only authenticated users can manage their own photos.

#### **Prerequisites**

*   Completion of the "Authorization and Centralized Error Handling" lab.
*   Your MySQL database server is running.
*   An API client like Postman or Insomnia that can send `multipart/form-data` requests.

#### **Learning Objectives**

By the end of this lab, you will be able to:

*   Understand what `multipart/form-data` is and why it's necessary for file uploads.
*   Configure and use the `multer` middleware to handle file uploads in Express.
*   Save uploaded files to the server's local filesystem.
*   Create a new database resource to store metadata about uploaded files.
*   Build secure endpoints for uploading, listing, and deleting user-owned photos.
*   Serve static files (like images) from an Express server.

---

### **Part 1: Core Concepts**

**1. `application/json` vs. `multipart/form-data`**

So far, we have only sent data to our API using the `application/json` content type. This is perfect for sending text-based data like a post's title or a user's email. However, you cannot embed binary data (like an image file) directly into JSON.

This is where `multipart/form-data` comes in. Think of it as a package with multiple compartments. You can put your regular text data (like a photo caption) in one compartment and the actual image file in another. When you send a request with this content type, the server can process each "part" of the form separately.

**2. What is `multer`?**

Express cannot handle `multipart/form-data` on its own. It needs help. `multer` is an Express middleware that acts as the "receptionist" for file uploads. Its job is to:

1.  Look for incoming `multipart/form-data` requests.
2.  Process the data, separating the text fields from the files.
3.  Take the uploaded file(s) and save them to a specified location on your server (e.g., a folder named `uploads/`).
4.  Attach information about the saved file (like its new filename and path) to the Express `req` object, making it available to your controller.

---

### **Part 2: Setup and Database Schema**

**1. Install `multer`**

In your project's terminal, install the `multer` package:

```bash
npm install multer
```

**2. Create the `photos` Table**

We need a table to store information about the photos. Each photo will belong to a user. Execute the following SQL in your MySQL client:

```sql
-- Make sure you are using the correct database
USE blogdatabase;

CREATE TABLE photos (
    id INT AUTO_INCREMENT PRIMARY KEY,
    caption VARCHAR(255),
    filePath VARCHAR(255) NOT NULL,
    userId INT NOT NULL,
    createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT fk_photo_user
        FOREIGN KEY (userId) REFERENCES users(id)
        ON DELETE CASCADE
);
```
> #### **Code Explanation**
> *   `caption`: An optional text field to describe the photo.
> *   `filePath`: This is the crucial field. We will store the path to the image file on our server's disk (e.g., `uploads/image-1678886400000.jpg`). We **do not** store the image itself in the database.
> *   `userId`: A foreign key that links this photo to the user who uploaded it.
> *   `ON DELETE CASCADE`: If a user is deleted, all their photo records will be automatically deleted from this table.

---

### **Part 3: Configuring Multer Middleware**

It's best practice to configure `multer` in its own dedicated middleware file.

*   Create a new file: `src/middlewares/multer.middleware.js`.

```javascript
// src/middlewares/multer.middleware.js
import multer from 'multer';
import path from 'path';

// Set up storage for uploaded files
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, 'uploads/'); // Specify the directory to save files
    },
    filename: (req, file, cb) => {
        // Create a unique filename to avoid overwriting files
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
        cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
    }
});

// Create the multer instance
const upload = multer({ storage: storage });

export default upload;
```

> #### **Code Explanation**
> *   `multer.diskStorage`: We're telling `multer` to save files to the local disk.
> *   `destination`: A function that tells `multer` where to save the files. It will save them in a folder named `uploads/` in your project's root. **You must create this `uploads/` folder yourself!**
> *   `filename`: A function to generate a unique name for each file. This prevents a user from uploading `photo.jpg` and overwriting someone else's `photo.jpg`. We combine the field name, a timestamp, and the original file extension to create a name that's almost guaranteed to be unique.
> *   We then create and export the configured `upload` instance.

---

### **Part 4: Building the Photo Resource (Service, Controller, Routes)**

We will follow our established architecture.

**1. Create the Photo Service (`photo.service.js`)**

This service will handle all database interactions for photos.

*   Create a new file: `src/services/photo.service.js`.

```javascript
// src/services/photo.service.js
import pool from '../config/db.js';
import { ApiError } from '../utils/ApiError.js';
import fs from 'fs/promises'; // Import Node.js file system module

export const createPhoto = async (photoData) => {
    const { caption, filePath, userId } = photoData;
    const [result] = await pool.query(
        'INSERT INTO photos (caption, filePath, userId) VALUES (?, ?, ?)',
        [caption, filePath, userId]
    );
    const [rows] = await pool.query('SELECT * FROM photos WHERE id = ?', [result.insertId]);
    return rows[0];
};

export const getPhotosByUserId = async (userId) => {
    const [photos] = await pool.query('SELECT * FROM photos WHERE userId = ?', [userId]);
    return photos;
};

export const deletePhoto = async (photoId, userId) => {
    // 1. Get photo to check ownership and get file path
    const [rows] = await pool.query('SELECT * FROM photos WHERE id = ?', [photoId]);
    if (rows.length === 0) {
        throw new ApiError(404, "Photo not found");
    }
    const photo = rows[0];

    // 2. Authorization check
    if (photo.userId !== userId) {
        throw new ApiError(403, "Forbidden: You do not have permission to delete this photo.");
    }

    // 3. Delete the physical file from the server
    try {
        await fs.unlink(photo.filePath);
    } catch (error) {
        console.error("Failed to delete file from filesystem:", error);
        // We can choose to continue and still delete the DB record,
        // or throw an error. For now, we'll log it and continue.
    }

    // 4. Delete the record from the database
    await pool.query('DELETE FROM photos WHERE id = ?', [photoId]);
    return;
};
```
> #### **Code Explanation**
> *   In `deletePhoto`, we have a critical new step: `await fs.unlink(photo.filePath)`. This uses Node's built-in file system module to **delete the actual image file** from our `uploads/` directory. If we only delete the database record, the file remains on our server, becoming "orphan" data that takes up disk space.

**2. Create the Photo Controller and Routes**

*   Create `src/controllers/photo.controller.js`:

```javascript
// src/controllers/photo.controller.js
import * as photoService from '../services/photo.service.js';
import { ApiResponse } from '../utils/ApiResponse.js';
import asyncHandler from 'express-async-handler';

export const uploadPhoto = asyncHandler(async (req, res) => {
    // Multer adds a `file` object to the request if a file was uploaded
    if (!req.file) {
        throw new ApiError(400, "Please upload a file");
    }

    const { caption } = req.body;
    const userId = req.user.id;
    const filePath = req.file.path; // Path where multer saved the file

    const photoData = { caption, filePath, userId };
    const newPhoto = await photoService.createPhoto(photoData);

    res.status(201).json(new ApiResponse(201, newPhoto, "Photo uploaded successfully"));
});

export const getUserPhotos = asyncHandler(async (req, res) => {
    const userId = req.user.id;
    const photos = await photoService.getPhotosByUserId(userId);
    res.status(200).json(new ApiResponse(200, photos, "User photos retrieved successfully"));
});

export const deleteUserPhoto = asyncHandler(async (req, res) => {
    const photoId = parseInt(req.params.id, 10);
    const userId = req.user.id;
    await photoService.deletePhoto(photoId, userId);
    res.status(200).json(new ApiResponse(200, null, "Photo deleted successfully"));
});
```

*   Create `src/routes/photo.routes.js`:

```javascript
// src/routes/photo.routes.js
import { Router } from 'express';
import * as photoController from '../controllers/photo.controller.js';
import { authMiddleware } from '../middlewares/auth.middleware.js';
import upload from '../middlewares/multer.middleware.js';

const router = Router();

// A user must be logged in for all photo routes
router.use(authMiddleware);

router.get('/', photoController.getUserPhotos);
router.delete('/:id', photoController.deleteUserPhoto);

// The 'upload' middleware processes the file upload with the field name 'photo'
router.post('/upload', upload.single('photo'), photoController.uploadPhoto);

export default router;
```
> #### **Code Explanation**
> *   `router.use(authMiddleware)`: A convenient way to apply the `authMiddleware` to all routes defined in this file.
> *   `upload.single('photo')`: This is the `multer` middleware in action. It tells `multer` to expect a single file in a form field named `photo`. If it finds one, it will process it and attach the file info to `req.file`.

---

### **Part 5: Final Integration**

**1. Serve the `uploads` Directory**

Our server can now save images, but no one can see them. We need to tell Express that the `uploads` folder is "public" and its contents can be served directly.

*   Open `index.js` and add the `express.static` middleware.

```javascript
// index.js
// ... (imports)

const app = express();
// ...

app.use(express.json());

// SERVE STATIC FILES
// This makes the 'uploads' directory publicly accessible
app.use('/uploads', express.static('uploads'));

// Mount the routes
// ...
app.use('/api/photos', photoRoutes); // Don't forget to import and mount
// ...
```

**2. Mount the New Routes in `index.js`**

Make sure you import and mount your new photo routes in your main `index.js` file, as shown above.

---

### **Part 6: Testing the Full Flow**

1.  **Create the Folder:** Manually create an empty `uploads` folder in the root of your project.
2.  **Start your server:** `node index.js`.
3.  **Login:** Get a valid JWT for a user.
4.  **Upload a Photo:** This is a new type of request in Postman.
    *   Set the method to `POST` and the URL to `http://localhost:3000/api/photos/upload`.
    *   Go to the **Authorization** tab, select "Bearer Token", and paste your JWT.
    *   Go to the **Body** tab and select **`form-data`**.
    *   In the key-value table, enter a key named `photo`. In the dropdown next to the key, change "Text" to "File". Now you can click "Select Files" and choose an image from your computer.
    *   You can add another key named `caption` (as "Text") with a value like "My first uploaded photo!".
    *   Click **Send**.
5.  **Check the Response:** You should get a `201 Created` response with the database record for your new photo. Note the `filePath`.
6.  **Verify:**
    *   Look inside your project's `uploads/` folder. You should see the new, uniquely named image file.
    *   Check your database's `photos` table. You should see the new record.
    *   Open your browser and navigate to `http://localhost:3000/` followed by the `filePath` from your response (e.g., `http://localhost:3000/uploads/photo-1678886400000.jpg`). You should see your image!
7.  **Test List and Delete:**
    *   Make a `GET` request to `/api/photos` (with the JWT) to see a list of your photos.
    *   Make a `DELETE` request to `/api/photos/:id` (with the JWT and the photo's ID) to delete the photo. Verify that both the database record and the file in the `uploads/` folder are gone.

Congratulations! You have successfully added file upload capabilities to your API, a major step in building full-featured, modern web applications.